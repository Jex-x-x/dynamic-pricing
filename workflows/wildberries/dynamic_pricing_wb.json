{
  "name": "WB Dynamic Pricing - Demand Detector",
  "description": "Dynamic pricing for Wildberries with Bitrix-friendly base price detection (v2.0)",
  "_n8n_workflow_id": "aiGMF7tsy3U2udXt",
  "_deployed_at": "2026-01-31",
  "_status": "production",
  "nodes": [
    {
      "id": "schedule-trigger",
      "name": "Every 30 min",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [240, 300],
      "parameters": {
        "rule": {
          "interval": [{"field": "minutes", "minutesInterval": 30}]
        }
      }
    },
    {
      "id": "get-config",
      "name": "Get Config",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [440, 300],
      "parameters": {
        "method": "GET",
        "url": "https://autopapyrus.com/local/api/dynamic_pricing_config_wb.php"
      }
    },
    {
      "id": "analyze-demand",
      "name": "Analyze Demand",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [640, 300],
      "parameters": {
        "jsCode": "// ANALYZE DEMAND FOR WILDBERRIES\n// –°—á–∏—Ç–∞–µ—Ç –∑–∞–∫–∞–∑—ã WB –∏–∑ Bitrix\n\nconst BITRIX_URL = '{{BITRIX_WEBHOOK_URL}}';\nconst config = $input.first().json;\nconst pricing = config.pricing || {};\n\nconst BASELINE = pricing.baseline_orders_day || 45;\nconst THRESHOLD_HIGH = pricing.threshold_high || 1.20;\nconst THRESHOLD_LOW = pricing.threshold_low || 0.80;\nconst STEP = pricing.step || 0.05;\nconst MAX_MULT = pricing.max_multiplier || 1.70;\nconst MIN_MULT = pricing.min_multiplier || 0.85;\nlet currentMult = pricing.current_multiplier || 1.0;\n\n// Moscow time (UTC+3)\nconst now = new Date();\nconst moscowOffset = 3 * 60;\nconst utcMs = now.getTime() + (now.getTimezoneOffset() * 60000);\nconst moscowMs = utcMs + (moscowOffset * 60000);\nconst moscowNow = new Date(moscowMs);\n\nconst hoursPassedToday = moscowNow.getHours() + (moscowNow.getMinutes() / 60);\nconst expectedOrders = Math.max(1, BASELINE * (hoursPassedToday / 24));\nconst midnightStr = moscowNow.toISOString().slice(0, 10) + ' 00:01:00';\n\nlet allOrders = [];\nlet start = 0;\nlet hasMore = true;\n\nwhile (hasMore && allOrders.length < 500) {\n  const response = await this.helpers.httpRequest({\n    method: 'POST',\n    url: `${BITRIX_URL}/sale.order.list`,\n    body: {\n      filter: { '>=dateInsert': midnightStr },\n      select: ['id', 'xmlId', 'dateInsert'],\n      start: start\n    },\n    headers: { 'Content-Type': 'application/json' }\n  });\n  \n  const orders = response.result?.orders || [];\n  allOrders = allOrders.concat(orders);\n  \n  if (response.next) {\n    start = response.next;\n  } else {\n    hasMore = false;\n  }\n}\n\n// Filter WB orders\nconst wbOrders = allOrders.filter(o => {\n  const xmlId = (o.xmlId || '').toUpperCase();\n  return xmlId.startsWith('WB_') || xmlId.startsWith('WILDBERRIES_');\n});\nconst actualOrders = wbOrders.length;\n\nconst ratio = actualOrders / expectedOrders;\nlet decision = 'hold';\nlet newMult = currentMult;\nlet reason = '';\n\nif (ratio > THRESHOLD_HIGH && currentMult < MAX_MULT) {\n  decision = 'raise';\n  newMult = Math.min(MAX_MULT, +(currentMult + STEP).toFixed(2));\n  reason = `Ratio ${ratio.toFixed(2)} > ${THRESHOLD_HIGH}`;\n} else if (ratio < THRESHOLD_LOW && currentMult > MIN_MULT) {\n  decision = 'lower';\n  newMult = Math.max(MIN_MULT, +(currentMult - STEP).toFixed(2));\n  reason = `Ratio ${ratio.toFixed(2)} < ${THRESHOLD_LOW}`;\n} else {\n  reason = `Ratio ${ratio.toFixed(2)} in range`;\n}\n\nconfig.pricing.current_multiplier = newMult;\nconfig.pricing.last_check = now.toISOString();\nconfig.pricing.last_decision = decision;\nconfig.pricing.last_reason = reason;\nconfig.pricing.moscow_hours = hoursPassedToday.toFixed(1);\nif (decision !== 'hold') {\n  config.pricing.last_change = now.toISOString();\n}\n\nreturn [{\n  json: {\n    timestamp: now.toISOString(),\n    moscow_hours: hoursPassedToday.toFixed(1),\n    decision: decision,\n    old_multiplier: currentMult,\n    new_multiplier: newMult,\n    reason: reason,\n    actual_orders: actualOrders,\n    expected_orders: expectedOrders.toFixed(1),\n    ratio: ratio.toFixed(2),\n    configToSave: config\n  }\n}];"
      }
    },
    {
      "id": "save-config",
      "name": "Save Config",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [840, 300],
      "parameters": {
        "method": "POST",
        "url": "https://autopapyrus.com/local/api/dynamic_pricing_config_wb.php",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {"name": "X-Token", "value": "{{CONFIG_TOKEN}}"},
            {"name": "Content-Type", "value": "application/json"}
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.configToSave) }}"
      }
    },
    {
      "id": "get-wb-prices",
      "name": "Get WB Prices",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1040, 300],
      "parameters": {
        "jsCode": "// GET WILDBERRIES PRICES\n\nconst WB_API_KEY = '{{WB_API_KEY}}';\nconst WB_API_BASE = 'https://discounts-prices-api.wildberries.ru';\n\nconst demandData = $('Analyze Demand').first().json;\nconst allPrices = [];\nlet offset = 0;\nconst limit = 1000;\nlet hasMore = true;\n\nwhile (hasMore) {\n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `${WB_API_BASE}/api/v2/list/goods/filter?limit=${limit}&offset=${offset}`,\n    headers: {\n      'Authorization': WB_API_KEY,\n      'Content-Type': 'application/json'\n    }\n  });\n\n  const items = response.data?.listGoods || [];\n\n  for (const item of items) {\n    allPrices.push({\n      offer_id: String(item.nmID),\n      nm_id: item.nmID,\n      vendor_code: item.vendorCode,\n      price: item.sizes?.[0]?.price || 0,\n      discount: item.discount || 0,\n      discounted_price: item.sizes?.[0]?.discountedPrice || 0\n    });\n  }\n\n  offset += limit;\n  hasMore = items.length === limit;\n\n  if (hasMore) {\n    await new Promise(resolve => setTimeout(resolve, 600));\n  }\n}\n\nreturn [{\n  json: {\n    ...demandData,\n    total_products: allPrices.length,\n    all_prices: allPrices\n  }\n}];"
      }
    },
    {
      "id": "calc-new-prices",
      "name": "Calculate New Prices",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1240, 300],
      "parameters": {
        "jsCode": "// CALCULATE NEW PRICES - Bitrix-friendly v2.0\n\nconst BASE_PRICES_URL = 'https://autopapyrus.com/local/api/dynamic_pricing_base_prices_wb.php';\nconst TOKEN = '{{CONFIG_TOKEN}}';\nconst TOLERANCE = 0.01;\n\nconst input = $input.first().json;\nconst allPrices = input.all_prices || [];\nconst multiplier = input.new_multiplier || 1.0;\nconst decision = input.decision || 'hold';\n\nlet savedBasePrices = {};\ntry {\n  const resp = await this.helpers.httpRequest({\n    method: 'GET',\n    url: BASE_PRICES_URL,\n    headers: { 'Content-Type': 'application/json' }\n  });\n  savedBasePrices = resp.prices || {};\n} catch (e) {\n  savedBasePrices = {};\n}\n\nconst pricesToUpdate = [];\nconst updatedBasePrices = { ...savedBasePrices };\nlet baseChangedCount = 0;\nlet newProductsCount = 0;\n\nfunction calcDiscount(basePrice, targetPrice) {\n  if (basePrice <= 0 || targetPrice >= basePrice) return 0;\n  return Math.round((1 - targetPrice / basePrice) * 100);\n}\n\nfunction wouldTriggerQuarantine(oldPrice, newPrice) {\n  return newPrice < oldPrice / 3;\n}\n\nfor (const item of allPrices) {\n  const offerId = String(item.offer_id);\n  const wbBasePrice = item.price;\n  const currentFinalPrice = item.discounted_price || wbBasePrice;\n  const savedBase = savedBasePrices[offerId];\n\n  if (!savedBase) {\n    updatedBasePrices[offerId] = wbBasePrice;\n    newProductsCount++;\n    \n    if (Math.abs(multiplier - 1.0) >= 0.01) {\n      const targetPrice = Math.round(wbBasePrice * multiplier);\n      if (!wouldTriggerQuarantine(currentFinalPrice, targetPrice)) {\n        pricesToUpdate.push({\n          nmID: item.nm_id,\n          offer_id: offerId,\n          price: wbBasePrice,\n          discount: calcDiscount(wbBasePrice, targetPrice),\n          target_price: targetPrice,\n          current_price: currentFinalPrice\n        });\n      }\n    }\n    continue;\n  }\n\n  const targetPrice = Math.round(savedBase * multiplier);\n  const diff = Math.abs(currentFinalPrice - targetPrice) / targetPrice;\n\n  if (diff < TOLERANCE) continue;\n\n  updatedBasePrices[offerId] = wbBasePrice;\n  baseChangedCount++;\n\n  if (Math.abs(multiplier - 1.0) < 0.01) continue;\n\n  const newTargetPrice = Math.round(wbBasePrice * multiplier);\n  if (wouldTriggerQuarantine(currentFinalPrice, newTargetPrice)) continue;\n\n  pricesToUpdate.push({\n    nmID: item.nm_id,\n    offer_id: offerId,\n    price: wbBasePrice,\n    discount: calcDiscount(wbBasePrice, newTargetPrice),\n    target_price: newTargetPrice,\n    current_price: currentFinalPrice\n  });\n}\n\nlet saveError = null;\ntry {\n  await this.helpers.httpRequest({\n    method: 'POST',\n    url: BASE_PRICES_URL,\n    headers: { 'Content-Type': 'application/json', 'X-Token': TOKEN },\n    body: JSON.stringify({ prices: updatedBasePrices })\n  });\n} catch (e) {\n  saveError = e.message || String(e);\n}\n\nreturn [{\n  json: {\n    multiplier,\n    decision,\n    total_products: allPrices.length,\n    new_products: newProductsCount,\n    base_prices_changed: baseChangedCount,\n    prices_to_update: pricesToUpdate.length,\n    prices: pricesToUpdate,\n    save_error: saveError\n  }\n}];"
      }
    },
    {
      "id": "check-prices",
      "name": "Has Updates?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1440, 300],
      "parameters": {
        "conditions": {
          "combinator": "and",
          "conditions": [
            {
              "leftValue": "={{ $json.prices_to_update }}",
              "rightValue": 0,
              "operator": {"type": "number", "operation": "gt"}
            }
          ]
        }
      }
    },
    {
      "id": "update-wb-prices",
      "name": "Update WB Prices",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1640, 200],
      "parameters": {
        "jsCode": "// UPDATE WILDBERRIES PRICES\n\nconst WB_API_KEY = '{{WB_API_KEY}}';\nconst WB_API_BASE = 'https://discounts-prices-api.wildberries.ru';\n\nconst calcData = $input.first().json;\nconst prices = calcData.prices || [];\n\nif (prices.length === 0) {\n  return [{ json: { ...calcData, success: 0, errors: 0, message: 'No prices to update' } }];\n}\n\nconst formattedPrices = prices.map(p => ({\n  nmID: parseInt(p.nmID),\n  price: parseInt(p.price),\n  discount: Math.max(0, Math.min(99, parseInt(p.discount) || 0))\n})).filter(p => p.nmID > 0 && p.price > 0);\n\nif (formattedPrices.length === 0) {\n  return [{ json: { ...calcData, success: 0, errors: 0, message: 'No valid prices' } }];\n}\n\nconst response = await this.helpers.httpRequest({\n  method: 'POST',\n  url: `${WB_API_BASE}/api/v2/upload/task`,\n  headers: {\n    'Authorization': WB_API_KEY,\n    'Content-Type': 'application/json'\n  },\n  body: { data: formattedPrices },\n  ignoreHttpStatusErrors: true,\n  returnFullResponse: true\n});\n\nconst statusCode = response.statusCode || response.status;\nconst body = response.body || response;\n\nlet result = {\n  success: 0,\n  errors: formattedPrices.length,\n  taskId: null,\n  statusCode: statusCode,\n  totalSent: formattedPrices.length\n};\n\nif (statusCode === 200 && body?.data?.id) {\n  result.success = formattedPrices.length;\n  result.errors = 0;\n  result.taskId = body.data.id;\n}\n\nreturn [{ json: { ...calcData, ...result } }];"
      }
    },
    {
      "id": "no-updates",
      "name": "No Updates Needed",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [1640, 400],
      "parameters": {}
    },
    {
      "id": "format-telegram",
      "name": "Format Telegram",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1840, 200],
      "parameters": {
        "jsCode": "const updateResult = $input.first().json;\nconst calcData = $('Calculate New Prices').first().json;\n\nconst multiplier = calcData.multiplier;\nconst decision = calcData.decision;\nconst baseChanged = calcData.base_prices_changed || 0;\nconst totalProducts = calcData.total_products || 0;\nconst newProducts = calcData.new_products || 0;\n\nconst updated = updateResult.success || 0;\nconst errors = updateResult.errors || 0;\nconst taskId = updateResult.taskId || null;\n\nif (updated === 0 && errors === 0 && baseChanged === 0 && newProducts === 0) {\n  return [{ json: { skip: true } }];\n}\n\nconst decisionRu = {\n  'raise': 'üìà –ü–û–í–´–®–ï–ù–ò–ï',\n  'lower': 'üìâ –°–ù–ò–ñ–ï–ù–ò–ï',\n  'hold': '‚û°Ô∏è –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô'\n};\n\nlet message = `üü£ *WB Dynamic Pricing*\\n\\n`;\nmessage += `${decisionRu[decision] || decision}\\n\\n`;\nmessage += `üìä –ú–Ω–æ–∂–∏—Ç–µ–ª—å: *${multiplier}*\\n`;\nmessage += `üì¶ –í—Å–µ–≥–æ —Ç–æ–≤–∞—Ä–æ–≤: *${totalProducts}*\\n`;\n\nif (newProducts > 0) message += `üÜï –ù–æ–≤—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤: *${newProducts}*\\n`;\nif (baseChanged > 0) message += `\\nüè¢ *–û–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∑ Bitrix:* ${baseChanged} —Ç–æ–≤–∞—Ä–æ–≤\\n`;\n\nif (updated > 0 || errors > 0) {\n  message += `\\nüí∞ *–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω:*\\n`;\n  message += `‚úÖ –£—Å–ø–µ—à–Ω–æ: *${updated}*\\n`;\n  if (errors > 0) message += `‚ùå –û—à–∏–±–æ–∫: *${errors}*\\n`;\n  if (taskId) message += `üìã Task ID: \\`${taskId}\\`\\n`;\n}\n\nreturn [{ json: { message, skip: false } }];"
      }
    },
    {
      "id": "send-telegram",
      "name": "Send Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [2040, 200],
      "parameters": {
        "operation": "sendMessage",
        "chatId": "{{TELEGRAM_CHAT_ID}}",
        "text": "={{ $json.message }}",
        "additionalFields": {"parse_mode": "Markdown"}
      },
      "credentials": {
        "telegramApi": {"id": "{{TELEGRAM_CREDENTIAL_ID}}", "name": "Telegram"}
      }
    }
  ],
  "connections": {
    "Every 30 min": {"main": [[{"node": "Get Config", "type": "main", "index": 0}]]},
    "Get Config": {"main": [[{"node": "Analyze Demand", "type": "main", "index": 0}]]},
    "Analyze Demand": {"main": [[{"node": "Save Config", "type": "main", "index": 0}]]},
    "Save Config": {"main": [[{"node": "Get WB Prices", "type": "main", "index": 0}]]},
    "Get WB Prices": {"main": [[{"node": "Calculate New Prices", "type": "main", "index": 0}]]},
    "Calculate New Prices": {"main": [[{"node": "Has Updates?", "type": "main", "index": 0}]]},
    "Has Updates?": {"main": [[{"node": "Update WB Prices", "type": "main", "index": 0}], [{"node": "No Updates Needed", "type": "main", "index": 0}]]},
    "Update WB Prices": {"main": [[{"node": "Format Telegram", "type": "main", "index": 0}]]},
    "Format Telegram": {"main": [[{"node": "Send Telegram", "type": "main", "index": 0}]]}
  },
  "settings": {"executionOrder": "v1"},
  "_variables_required": [
    "WB_API_KEY - Wildberries API —Ç–æ–∫–µ–Ω",
    "BITRIX_WEBHOOK_URL - URL –≤–µ–±—Ö—É–∫–∞ Bitrix",
    "CONFIG_TOKEN - —Ç–æ–∫–µ–Ω –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ storage",
    "TELEGRAM_CHAT_ID - ID —á–∞—Ç–∞ Telegram",
    "TELEGRAM_CREDENTIAL_ID - ID credentials Telegram –≤ n8n"
  ]
}
