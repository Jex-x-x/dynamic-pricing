{
  "name": "WB Dynamic Pricing - Demand Detector",
  "description": "Dynamic pricing for Wildberries with Bitrix-friendly base price detection (v2.0)",
  "nodes": [
    {
      "id": "schedule-trigger",
      "name": "Every 30 min",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [240, 300],
      "parameters": {
        "rule": {
          "interval": [{"field": "minutes", "minutesInterval": 30}]
        }
      }
    },
    {
      "id": "get-config",
      "name": "Get Config",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [440, 300],
      "parameters": {
        "method": "GET",
        "url": "={{ $vars.WB_CONFIG_URL }}"
      }
    },
    {
      "id": "analyze-demand",
      "name": "Analyze Demand",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [640, 300],
      "parameters": {
        "jsCode": "// ============================================\n// ANALYZE DEMAND - Calculate multiplier\n// –í—Ä–µ–º—è –ø–æ –ú–æ—Å–∫–≤–µ (UTC+3)\n// ============================================\n\nconst config = $input.first().json;\nconst pricing = config.pricing || {};\n\n// Config defaults\nconst BASELINE = pricing.baseline_orders_day || 45;\nconst THRESHOLD_HIGH = pricing.threshold_high || 1.2;\nconst THRESHOLD_LOW = pricing.threshold_low || 0.8;\nconst STEP = pricing.step || 0.05;\nconst MAX_MULT = pricing.max_multiplier || 1.70;\nconst MIN_MULT = pricing.min_multiplier || 0.85;\n\nlet currentMult = pricing.current_multiplier || 1.0;\n\n// Moscow time (UTC+3)\nconst now = new Date();\nconst moscowOffset = 3 * 60;\nconst localOffset = now.getTimezoneOffset();\nconst moscowTime = new Date(now.getTime() + (moscowOffset + localOffset) * 60 * 1000);\nconst moscowHours = moscowTime.getHours() + moscowTime.getMinutes() / 60;\n\n// Expected orders by this time (proportional)\nconst expected = BASELINE * (moscowHours / 24);\n\n// TODO: Get actual WB orders from your order source\n// For now using 0, replace with actual order count\nconst actualOrders = 0;\n\nconst ratio = expected > 0 ? actualOrders / expected : 0;\n\nlet decision = 'hold';\nlet reason = '';\nlet newMult = currentMult;\n\nif (ratio > THRESHOLD_HIGH) {\n  newMult = Math.min(MAX_MULT, currentMult + STEP);\n  decision = newMult > currentMult ? 'increase' : 'hold_max';\n  reason = `High demand: ratio ${ratio.toFixed(2)} > ${THRESHOLD_HIGH}`;\n} else if (ratio < THRESHOLD_LOW) {\n  newMult = Math.max(MIN_MULT, currentMult - STEP);\n  decision = newMult < currentMult ? 'decrease' : 'hold_min';\n  reason = `Low demand: ratio ${ratio.toFixed(2)} < ${THRESHOLD_LOW}`;\n} else {\n  decision = 'hold';\n  reason = `Ratio ${ratio.toFixed(2)} in range [${THRESHOLD_LOW}-${THRESHOLD_HIGH}]`;\n}\n\nnewMult = Math.round(newMult * 100) / 100;\n\nreturn [{\n  json: {\n    ...config,\n    pricing: {\n      ...pricing,\n      current_multiplier: newMult,\n      last_check: new Date().toISOString(),\n      last_decision: decision,\n      last_reason: `${reason} (${actualOrders} vs ${expected.toFixed(1)} expected)`,\n      moscow_hours: moscowHours.toFixed(1),\n      last_change: decision !== 'hold' ? new Date().toISOString() : pricing.last_change\n    }\n  }\n}];"
      }
    },
    {
      "id": "save-config",
      "name": "Save Config",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [840, 300],
      "parameters": {
        "method": "POST",
        "url": "={{ $vars.WB_CONFIG_URL }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {"name": "X-Token", "value": "={{ $vars.CONFIG_TOKEN }}"}
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}"
      }
    },
    {
      "id": "get-wb-prices",
      "name": "Get WB Prices",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1040, 300],
      "parameters": {
        "jsCode": "// ============================================\n// GET WILDBERRIES PRICES - with pagination\n// Rate limit: 10 requests per 6 seconds\n// ============================================\n\nconst WB_API_KEY = $vars.WB_API_KEY;\nconst WB_API_BASE = 'https://discounts-prices-api.wildberries.ru';\n\nconst allPrices = [];\nlet offset = 0;\nconst limit = 1000;\nlet hasMore = true;\n\nwhile (hasMore) {\n  const response = await fetch(\n    `${WB_API_BASE}/api/v2/list/goods/filter?limit=${limit}&offset=${offset}`,\n    {\n      method: 'GET',\n      headers: {\n        'Authorization': WB_API_KEY,\n        'Content-Type': 'application/json'\n      }\n    }\n  );\n\n  if (!response.ok) {\n    throw new Error(`WB API error: ${response.status}`);\n  }\n\n  const data = await response.json();\n  const items = data.data?.listGoods || [];\n\n  for (const item of items) {\n    allPrices.push({\n      offer_id: String(item.nmID),\n      nm_id: item.nmID,\n      vendor_code: item.vendorCode,\n      // WB model: price is base, discountedPrice is final\n      price: item.sizes?.[0]?.price || 0,\n      discount: item.discount || 0,\n      discounted_price: item.sizes?.[0]?.discountedPrice || 0\n    });\n  }\n\n  offset += limit;\n  hasMore = items.length === limit;\n\n  // Rate limiting: max 10 requests per 6 seconds\n  if (hasMore) {\n    await new Promise(resolve => setTimeout(resolve, 600));\n  }\n}\n\nconst prevNode = $('Save Config').first().json;\n\nreturn [{\n  json: {\n    ...prevNode,\n    total_products: allPrices.length,\n    all_prices: allPrices\n  }\n}];"
      }
    },
    {
      "id": "calc-new-prices",
      "name": "Calculate New Prices",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1240, 300],
      "parameters": {
        "jsCode": "// ============================================\n// CALCULATE NEW PRICES - Bitrix-friendly v2.0\n// \n// –õ–æ–≥–∏–∫–∞:\n// 1. –ï—Å–ª–∏ currentPrice ‚âà savedBase √ó multiplier (¬±1%) ‚Üí –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞—Ç—å\n// 2. –ï—Å–ª–∏ currentPrice ‚â† —Ü–µ–ª–µ–≤–æ–π ‚Üí Bitrix –æ–±–Ω–æ–≤–∏–ª –±–∞–∑—É\n//    ‚Üí –ø—Ä–∏–Ω—è—Ç—å –∫–∞–∫ –Ω–æ–≤—É—é –±–∞–∑—É\n//    ‚Üí –ø—Ä–∏–º–µ–Ω–∏—Ç—å multiplier —á–µ—Ä–µ–∑ discount\n//    ‚Üí –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ WB\n//\n// WB –º–æ–¥–µ–ª—å: finalPrice = price √ó (1 - discount/100)\n// ============================================\n\nconst input = $input.first().json;\nconst allPrices = input.all_prices || [];\nconst multiplier = input.pricing?.current_multiplier || 1.0;\n\n// Load saved base prices\nconst BASE_PRICES_URL = $vars.WB_BASE_PRICES_URL;\nlet savedBasePrices = {};\n\ntry {\n  const response = await fetch(BASE_PRICES_URL);\n  const data = await response.json();\n  savedBasePrices = data.prices || {};\n} catch (e) {\n  console.log('No saved base prices, starting fresh');\n}\n\nconst TOLERANCE = 0.01; // 1%\nconst pricesToUpdate = [];\nconst updatedBasePrices = { ...savedBasePrices };\nlet baseChangedCount = 0;\nlet newProductsCount = 0;\n\n// Helper: calculate discount % to achieve target price\nfunction calcDiscount(basePrice, targetPrice) {\n  if (basePrice <= 0) return 0;\n  if (targetPrice >= basePrice) return 0;\n  return Math.round((1 - targetPrice / basePrice) * 100);\n}\n\n// Helper: check if price change would trigger quarantine (>3x drop)\nfunction wouldTriggerQuarantine(oldPrice, newPrice) {\n  return newPrice < oldPrice / 3;\n}\n\nfor (const item of allPrices) {\n  const offerId = String(item.offer_id);\n  // –í WB: price = –±–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞, discounted_price = —Ñ–∏–Ω–∞–ª—å–Ω–∞—è\n  const wbBasePrice = item.price;  // –ë–∞–∑–∞ –≤ WB\n  const currentFinalPrice = item.discounted_price || wbBasePrice;\n  const savedBase = savedBasePrices[offerId];\n\n  // New product - save WB base price\n  if (!savedBase) {\n    updatedBasePrices[offerId] = wbBasePrice;\n    newProductsCount++;\n    continue;\n  }\n\n  // Calculate what the target price SHOULD be\n  const targetPrice = Math.round(savedBase * multiplier);\n  \n  // Check if current final price matches target (¬±1%)\n  const diff = Math.abs(currentFinalPrice - targetPrice) / targetPrice;\n\n  if (diff < TOLERANCE) {\n    // Price is correct, nothing to do\n    continue;\n  }\n\n  // Price doesn't match target ‚Üí Bitrix updated the base in WB\n  // Accept WB's current base price as the new base\n  updatedBasePrices[offerId] = wbBasePrice;\n  baseChangedCount++;\n\n  // Skip if multiplier is ~1.0 (no dynamic pricing needed)\n  if (Math.abs(multiplier - 1.0) < 0.01) {\n    continue;\n  }\n\n  // Calculate new target from the NEW base\n  const newTargetPrice = Math.round(wbBasePrice * multiplier);\n\n  // Check quarantine risk\n  if (wouldTriggerQuarantine(currentFinalPrice, newTargetPrice)) {\n    console.log(`Skipping ${offerId}: would trigger quarantine`);\n    continue;\n  }\n\n  // Calculate discount % to achieve target\n  const newDiscount = calcDiscount(wbBasePrice, newTargetPrice);\n\n  pricesToUpdate.push({\n    nmID: item.nm_id,\n    offer_id: offerId,\n    price: wbBasePrice,        // Keep WB base price\n    discount: newDiscount,      // Adjust discount to achieve target\n    target_price: newTargetPrice,\n    current_price: currentFinalPrice,\n    previous_base: savedBase,\n    new_base: wbBasePrice\n  });\n}\n\nreturn [{\n  json: {\n    multiplier,\n    decision: input.pricing?.last_decision || 'hold',\n    total_products: allPrices.length,\n    new_products: newProductsCount,\n    base_prices_changed: baseChangedCount,\n    prices_to_update: pricesToUpdate.length,\n    prices: pricesToUpdate,\n    updated_base_prices: updatedBasePrices\n  }\n}];"
      }
    },
    {
      "id": "check-prices",
      "name": "Has Updates?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1440, 300],
      "parameters": {
        "conditions": {
          "options": {"caseSensitive": true, "leftValue": ""},
          "combinator": "and",
          "conditions": [
            {
              "leftValue": "={{ $json.prices_to_update }}",
              "rightValue": 0,
              "operator": {"type": "number", "operation": "gt"}
            }
          ]
        }
      }
    },
    {
      "id": "update-wb-prices",
      "name": "Update WB Prices",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1640, 200],
      "parameters": {
        "jsCode": "// ============================================\n// UPDATE WILDBERRIES PRICES\n// –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ upload/task\n// ============================================\n\nconst input = $input.first().json;\nconst prices = input.prices || [];\n\nif (prices.length === 0) {\n  return [{ json: { ...input, update_result: { success: 0, errors: 0 } } }];\n}\n\nconst WB_API_KEY = $vars.WB_API_KEY;\nconst WB_API_BASE = 'https://discounts-prices-api.wildberries.ru';\n\n// Format for WB API\nconst formattedPrices = prices.map(p => ({\n  nmID: p.nmID,\n  price: p.price,\n  discount: p.discount\n}));\n\nconst response = await fetch(`${WB_API_BASE}/api/v2/upload/task`, {\n  method: 'POST',\n  headers: {\n    'Authorization': WB_API_KEY,\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({ data: formattedPrices })\n});\n\nlet updateResult = {\n  success: 0,\n  errors: 0,\n  taskId: null,\n  errorMessage: null\n};\n\nif (response.ok) {\n  const data = await response.json();\n  updateResult.taskId = data.data?.id;\n  updateResult.success = prices.length;\n} else {\n  updateResult.errors = prices.length;\n  updateResult.errorMessage = await response.text();\n}\n\n// Save updated base prices\nconst BASE_PRICES_URL = $vars.WB_BASE_PRICES_URL;\nconst TOKEN = $vars.CONFIG_TOKEN;\n\nlet saveError = null;\ntry {\n  const saveResponse = await fetch(BASE_PRICES_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Token': TOKEN\n    },\n    body: JSON.stringify({ prices: input.updated_base_prices })\n  });\n  if (!saveResponse.ok) {\n    saveError = await saveResponse.text();\n  }\n} catch (e) {\n  saveError = e.message;\n}\n\nreturn [{ json: { ...input, update_result: updateResult, save_error: saveError } }];"
      }
    },
    {
      "id": "no-updates",
      "name": "No Updates Needed",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [1640, 400]
    },
    {
      "id": "format-telegram",
      "name": "Format Telegram",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1840, 200],
      "parameters": {
        "jsCode": "// Format Telegram message for WB\nconst input = $input.first().json;\nconst result = input.update_result || {};\nconst mult = input.multiplier || 1.0;\nconst decision = input.decision || 'hold';\nconst baseChanged = input.base_prices_changed || 0;\nconst newProducts = input.new_products || 0;\n\nlet emoji = '‚û°Ô∏è';\nif (decision === 'increase') emoji = 'üìà';\nif (decision === 'decrease') emoji = 'üìâ';\n\nlet message = `üü£ *WB Dynamic Pricing*\\n\\n`;\nmessage += `${emoji} ${decision.toUpperCase()}\\n\\n`;\nmessage += `üìä –ú–Ω–æ–∂–∏—Ç–µ–ª—å: *${mult}*\\n`;\nmessage += `üì¶ –í—Å–µ–≥–æ —Ç–æ–≤–∞—Ä–æ–≤: *${input.total_products}*\\n`;\n\nif (newProducts > 0) {\n  message += `üÜï –ù–æ–≤—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤: *${newProducts}*\\n`;\n}\n\nif (baseChanged > 0) {\n  message += `\\nüè¢ *–û–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∑ Bitrix:* ${baseChanged} —Ç–æ–≤–∞—Ä–æ–≤\\n`;\n}\n\nif (result.success > 0 || result.errors > 0) {\n  message += `\\nüí∞ *–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω:*\\n`;\n  message += `‚úÖ –£—Å–ø–µ—à–Ω–æ: *${result.success}*\\n`;\n  if (result.errors > 0) {\n    message += `‚ùå –û—à–∏–±–æ–∫: *${result.errors}*\\n`;\n  }\n  if (result.taskId) {\n    message += `üìã Task ID: \\`${result.taskId}\\`\\n`;\n  }\n}\n\nif (input.save_error) {\n  message += `\\n‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –±–∞–∑: ${input.save_error}\\n`;\n}\n\nreturn [{ json: { message, skip: false } }];"
      }
    },
    {
      "id": "send-telegram",
      "name": "Send Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [2040, 200],
      "parameters": {
        "chatId": "={{ $vars.TELEGRAM_CHAT_ID }}",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "credentials": {
        "telegramApi": {
          "id": "YOUR_TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram"
        }
      }
    }
  ],
  "connections": {
    "Every 30 min": {"main": [[{"node": "Get Config"}]]},
    "Get Config": {"main": [[{"node": "Analyze Demand"}]]},
    "Analyze Demand": {"main": [[{"node": "Save Config"}]]},
    "Save Config": {"main": [[{"node": "Get WB Prices"}]]},
    "Get WB Prices": {"main": [[{"node": "Calculate New Prices"}]]},
    "Calculate New Prices": {"main": [[{"node": "Has Updates?"}]]},
    "Has Updates?": {"main": [[{"node": "Update WB Prices"}], [{"node": "No Updates Needed"}]]},
    "Update WB Prices": {"main": [[{"node": "Format Telegram"}]]},
    "Format Telegram": {"main": [[{"node": "Send Telegram"}]]}
  },
  "settings": {
    "executionOrder": "v1"
  },
  "_variables_required": [
    "WB_API_KEY - Wildberries API –∫–ª—é—á",
    "WB_CONFIG_URL - URL –∫ dynamic_pricing_config_wb.php",
    "WB_BASE_PRICES_URL - URL –∫ dynamic_pricing_base_prices_wb.php",
    "CONFIG_TOKEN - —Ç–æ–∫–µ–Ω –¥–ª—è –∑–∞–ø–∏—Å–∏",
    "TELEGRAM_CHAT_ID - ID —á–∞—Ç–∞ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"
  ]
}
